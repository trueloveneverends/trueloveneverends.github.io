<!DOCTYPE html>
<html>
<head>
    <title>WWZç¼–ç¨‹è¯­è¨€-åŠ©åŠ›ä¸–ç•Œå’Œå¹³</title>
    <meta charset="UTF-8">
    <style>
      
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #5f72bd 0%, #9b23ea 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }

        .panel {
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.05);
            padding: 25px;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .panel-header h2 {
            color: #333;
            font-size: 1.5em;
        }

        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .line-numbers {
            position: absolute;
            left: 0;
            top: 0;
            width: 50px;
            padding: 12px 5px;
            background: #f8f8f8;
            border-right: 1px solid #e0e0e0;
            color: #999;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 21px;
            text-align: right;
            user-select: none;
        }

        .code-wrapper {
            position: relative;
            flex: 1;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
        }

        #code {
            width: 100%;
            height: 100%;
            padding: 12px 12px 12px 62px;
            font-family: 'Consolas', 'Monaco', 'Microsoft YaHei', monospace;
            font-size: 14px;
            line-height: 21px;
            border: none;
            outline: none;
            resize: none;
            background: #fafafa;
            color: #333;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #666;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .output-area {
            flex: 1;
            background: #f8f8f8;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.6;
            overflow-y: auto;
            white-space: pre-wrap;
            min-height: 300px;
        }

        .error {
            color: #e53e3e;
            font-weight: 600;
        }

        .success {
            color: #38a169;
            font-weight: 600;
        }

        .warning {
            color: #d69e2e;
            font-weight: 600;
        }

        .info {
            color: #3182ce;
            font-weight: 600;
        }

        .syntax-guide {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .syntax-section {
            margin-bottom: 20px;
        }

        .syntax-section h4 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .syntax-example {
            background: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-family: 'Consolas', monospace;
            font-size: 13px;
            margin-bottom: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            font-weight: 500;
            color: #666;
        }

        .tab:hover {
            color: #333;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .examples-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .example-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .example-card:hover {
            border-color: #667eea;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }

        .example-card h5 {
            color: #333;
            margin-bottom: 5px;
        }

        .example-card p {
            color: #666;
            font-size: 13px;
        }

        .console-log {
            padding: 5px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        .console-log:last-child {
            border-bottom: none;
        }

        @media (max-width: 968px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>WWZç¼–ç¨‹è¯­è¨€ 2.0</h1>
            <p>è‡ªç„¶è¯­è¨€ç¼–ç¨‹å®éªŒæ›´ç®€å•ã€æ›´è‡ªç„¶</p>
        </div>

        <div class="content">
            <div class="panel">
                <div class="panel-header">
                    <h2>ä»£ç ç¼–è¾‘å™¨</h2>
                    <div>
                        <span id="cursor-position">è¡Œ 1, åˆ— 1</span>
                    </div>
                </div>

                <div class="editor-container">
                    <div class="code-wrapper">
                        <div class="line-numbers" id="lineNumbers">1</div>
                        <textarea id="code" placeholder="åœ¨è¿™é‡Œè¾“å…¥æ‚¨çš„æ±‰è¯­ä»£ç ..." spellcheck="false">
// ç»å…¸ç®—æ³•å®ç°
è¾“å‡º "=== æ’åºç®—æ³•ç¤ºä¾‹ ==="

// å†’æ³¡æ’åº
å®šä¹‰ å‡½æ•° å†’æ³¡æ’åº å‚æ•°ä¸º æ•°ç»„
    å®šä¹‰ å˜é‡ é•¿åº¦ ç­‰äº æ•°ç»„çš„é•¿åº¦
    å®šä¹‰ å˜é‡ i ç­‰äº 0
    
    å½“ i å°äº é•¿åº¦ å‡å» 1 æ—¶
        å®šä¹‰ å˜é‡ j ç­‰äº 0
        å½“ j å°äº é•¿åº¦ å‡å» i å‡å» 1 æ—¶
            å¦‚æœ æ•°ç»„[j] å¤§äº æ•°ç»„[j åŠ ä¸Š 1] é‚£ä¹ˆ
                // äº¤æ¢å…ƒç´ 
                å®šä¹‰ å˜é‡ ä¸´æ—¶ ç­‰äº æ•°ç»„[j]
                æ•°ç»„[j] ç­‰äº æ•°ç»„[j åŠ ä¸Š 1]
                æ•°ç»„[j åŠ ä¸Š 1] ç­‰äº ä¸´æ—¶
            ç»“æŸ
            j ç­‰äº j åŠ ä¸Š 1
        ç»“æŸ
        i ç­‰äº i åŠ ä¸Š 1
    ç»“æŸ
    
    è¿”å› æ•°ç»„
ç»“æŸ

å®šä¹‰ å˜é‡ æµ‹è¯•æ•°ç»„ ç­‰äº [64, 34, 25, 12, 22, 11, 90]
è¾“å‡º "åŸå§‹æ•°ç»„ï¼š" åŠ ä¸Š æµ‹è¯•æ•°ç»„
å®šä¹‰ å˜é‡ æ’åºå ç­‰äº è°ƒç”¨ å†’æ³¡æ’åº ä¼ å…¥ æµ‹è¯•æ•°ç»„
è¾“å‡º "æ’åºåï¼š" åŠ ä¸Š æ’åºå

// äºŒåˆ†æŸ¥æ‰¾
è¾“å‡º "\n=== äºŒåˆ†æŸ¥æ‰¾ç¤ºä¾‹ ==="
å®šä¹‰ å‡½æ•° äºŒåˆ†æŸ¥æ‰¾ å‚æ•°ä¸º æ•°ç»„, ç›®æ ‡
    å®šä¹‰ å˜é‡ å·¦ ç­‰äº 0
    å®šä¹‰ å˜é‡ å³ ç­‰äº æ•°ç»„çš„é•¿åº¦ å‡å» 1
    
    å½“ å·¦ å°äºç­‰äº å³ æ—¶
        å®šä¹‰ å˜é‡ ä¸­é—´ ç­‰äº å–æ•´((å·¦ åŠ ä¸Š å³) é™¤ä»¥ 2)
        
        å¦‚æœ æ•°ç»„[ä¸­é—´] ç­‰äº ç›®æ ‡ é‚£ä¹ˆ
            è¿”å› ä¸­é—´
        å¦åˆ™å¦‚æœ æ•°ç»„[ä¸­é—´] å°äº ç›®æ ‡ é‚£ä¹ˆ
            å·¦ ç­‰äº ä¸­é—´ åŠ ä¸Š 1
        å¦åˆ™
            å³ ç­‰äº ä¸­é—´ å‡å» 1
        ç»“æŸ
    ç»“æŸ
    
    è¿”å› -1
ç»“æŸ

å®šä¹‰ å˜é‡ æœ‰åºæ•°ç»„ ç­‰äº [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
è¾“å‡º "åœ¨æ•°ç»„" åŠ ä¸Š æœ‰åºæ•°ç»„ åŠ ä¸Š "ä¸­æŸ¥æ‰¾ï¼š"

å¾ªç¯ ç›®æ ‡å€¼ åœ¨ [7, 10, 1, 19] ä¸­
    å®šä¹‰ å˜é‡ ä½ç½® ç­‰äº è°ƒç”¨ äºŒåˆ†æŸ¥æ‰¾ ä¼ å…¥ æœ‰åºæ•°ç»„, ç›®æ ‡å€¼
    å¦‚æœ ä½ç½® ä¸ç­‰äº -1 é‚£ä¹ˆ
        è¾“å‡º "  " åŠ ä¸Š ç›®æ ‡å€¼ åŠ ä¸Š " åœ¨ä½ç½® " åŠ ä¸Š ä½ç½®
    å¦åˆ™
        è¾“å‡º "  " åŠ ä¸Š ç›®æ ‡å€¼ åŠ ä¸Š " æœªæ‰¾åˆ°"
    ç»“æŸ
ç»“æŸ

// æœ€å¤§å…¬çº¦æ•°ï¼ˆæ¬§å‡ é‡Œå¾—ç®—æ³•ï¼‰
è¾“å‡º "\n=== æœ€å¤§å…¬çº¦æ•°ç¤ºä¾‹ ==="
å®šä¹‰ å‡½æ•° æœ€å¤§å…¬çº¦æ•° å‚æ•°ä¸º a, b
    å½“ b ä¸ç­‰äº 0 æ—¶
        å®šä¹‰ å˜é‡ ä¸´æ—¶ ç­‰äº b
        b ç­‰äº a å–ä½™ b
        a ç­‰äº ä¸´æ—¶
    ç»“æŸ
    è¿”å› a
ç»“æŸ

å®šä¹‰ å˜é‡ æ•°å¯¹åˆ—è¡¨ ç­‰äº [[48, 18], [100, 35], [17, 19]]
å¾ªç¯ æ•°å¯¹ åœ¨ æ•°å¯¹åˆ—è¡¨ ä¸­
    å®šä¹‰ å˜é‡ ç»“æœ ç­‰äº è°ƒç”¨ æœ€å¤§å…¬çº¦æ•° ä¼ å…¥ æ•°å¯¹[0], æ•°å¯¹[1]
    è¾“å‡º æ•°å¯¹[0] åŠ ä¸Š " å’Œ " åŠ ä¸Š æ•°å¯¹[1] åŠ ä¸Š " çš„æœ€å¤§å…¬çº¦æ•°æ˜¯ " åŠ ä¸Š ç»“æœ
ç»“æŸ</textarea>
                    </div>

                    <div class="controls">
                        <button class="btn-primary" onclick="runCode()">
                            â–¶ï¸ è¿è¡Œä»£ç 
                        </button>
                        <button class="btn-secondary" onclick="clearCode()">
                            ğŸ—‘ï¸ æ¸…ç©º
                        </button>
                        <button class="btn-secondary" onclick="formatCode()">
                            ğŸ“ æ ¼å¼åŒ–
                        </button>
                        <button class="btn-secondary" onclick="saveCode()">
                            ğŸ’¾ ä¿å­˜
                        </button>
                        <button class="btn-secondary" onclick="loadCode()">
                            ğŸ“ åŠ è½½
                        </button>
                    </div>
                </div>

                <div class="syntax-guide">
                    <h3>è¯­æ³•å‚è€ƒæŒ‡å—</h3>
                    
                    <div class="syntax-section">
                        <h4>ğŸ“Œ åŸºç¡€è¯­æ³•</h4>
                        <div class="syntax-example">å®šä¹‰ å˜é‡ åç§° ç­‰äº å€¼</div>
                        <div class="syntax-example">è¾“å‡º "æ–‡æœ¬" æˆ– å˜é‡</div>
                        <div class="syntax-example">// è¿™æ˜¯æ³¨é‡Š</div>
                    </div>

                    <div class="syntax-section">
                        <h4>ğŸ”„ æ§åˆ¶æµç¨‹</h4>
                        <div class="syntax-example">å¦‚æœ æ¡ä»¶ é‚£ä¹ˆ ... å¦åˆ™ ... ç»“æŸ</div>
                        <div class="syntax-example">å¾ªç¯ å˜é‡ åœ¨ åˆ—è¡¨ ä¸­ ... ç»“æŸ</div>
                        <div class="syntax-example">å½“ æ¡ä»¶ æ—¶ ... ç»“æŸ</div>
                    </div>

                    <div class="syntax-section">
                        <h4>ğŸ¯ å‡½æ•°å®šä¹‰</h4>
                        <div class="syntax-example">å®šä¹‰ å‡½æ•° åç§° å‚æ•°ä¸º å‚æ•°1, å‚æ•°2 ... ç»“æŸ</div>
                        <div class="syntax-example">è¿”å› å€¼</div>
                        <div class="syntax-example">è°ƒç”¨ å‡½æ•°å ä¼ å…¥ å‚æ•°1, å‚æ•°2</div>
                    </div>

                    <div class="syntax-section">
                        <h4>ğŸ“Š æ•°æ®ç»“æ„</h4>
                        <div class="syntax-example">æ•°ç»„ï¼š[å…ƒç´ 1, å…ƒç´ 2, ...]</div>
                        <div class="syntax-example">è®¿é—®ï¼šæ•°ç»„[ç´¢å¼•]</div>
                        <div class="syntax-example">èµ‹å€¼ï¼šæ•°ç»„[ç´¢å¼•] ç­‰äº å€¼</div>
                        <div class="syntax-example">æ·»åŠ  å…ƒç´  åˆ° æ•°ç»„</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-header">
                    <h2>è¿è¡Œç»“æœ</h2>
                    <button class="btn-secondary" onclick="clearOutput()" style="padding: 5px 15px;">
                        æ¸…ç©ºè¾“å‡º
                    </button>
                </div>

                <div class="output-area" id="output"></div>
            </div>
        </div>
    </div>

    <script>
        // ä¿®å¤åçš„æ±‰è¯­ç¼–ç¨‹è¯­è¨€è§£é‡Šå™¨
        class ChineseInterpreter {
            constructor() {
                this.reset();
            }

            reset() {
                this.variables = new Map();
                this.functions = new Map();
                this.classes = new Map();
                this.output = [];
                this.errors = [];
                this.callStack = [];
                this.loopStack = [];
                this.currentLine = 0;
                
                // å†…ç½®å‡½æ•°
                this.builtins = new Map([
                    ['é•¿åº¦', (args) => {
                        const obj = args[0];
                        if (typeof obj === 'string' || Array.isArray(obj)) {
                            return obj.length;
                        } else if (obj instanceof Map) {
                            return obj.size;
                        }
                        throw new Error('é•¿åº¦å‡½æ•°åªèƒ½ç”¨äºå­—ç¬¦ä¸²ã€æ•°ç»„æˆ–å­—å…¸');
                    }],
                    ['å–æ•´', (args) => Math.floor(args[0])],
                    ['å–ä¸Šæ•´', (args) => Math.ceil(args[0])],
                    ['ç»å¯¹å€¼', (args) => Math.abs(args[0])],
                    ['å¹³æ–¹æ ¹', (args) => Math.sqrt(args[0])],
                ]);
            }

            // è¯æ³•åˆ†æå™¨
            tokenize(code) {
                const lines = code.split('\n');
                const tokens = [];
                
                for (let lineNum = 0; lineNum < lines.length; lineNum++) {
                    const line = lines[lineNum];
                    
                    // è·³è¿‡ç©ºè¡Œ
                    if (line.trim() === '') {
                        tokens.push({ type: 'NEWLINE', value: '\n', line: lineNum + 1 });
                        continue;
                    }
                    
                    // å¤„ç†æ³¨é‡Š
                    if (line.trim().startsWith('//')) {
                        tokens.push({ type: 'NEWLINE', value: '\n', line: lineNum + 1 });
                        continue;
                    }
                    
                    // æå–è¡Œä¸­çš„æ‰€æœ‰token
                    const lineTokens = this.tokenizeLine(line, lineNum + 1);
                    tokens.push(...lineTokens);
                    
                    // æ·»åŠ æ¢è¡Œæ ‡è®°
                    tokens.push({ type: 'NEWLINE', value: '\n', line: lineNum + 1 });
                }
                
                return tokens;
            }

            tokenizeLine(line, lineNum) {
                const tokens = [];
                const keywords = [
                    'å®šä¹‰', 'å˜é‡', 'ç­‰äº', 'å¦‚æœ', 'é‚£ä¹ˆ', 'å¦åˆ™', 'å¦åˆ™å¦‚æœ', 'ç»“æŸ',
                    'å¾ªç¯', 'åœ¨', 'ä¸­', 'å½“', 'æ—¶', 'å‡½æ•°', 'å‚æ•°ä¸º', 'è¿”å›', 'è°ƒç”¨',
                    'ä¼ å…¥', 'è¾“å‡º', 'åŠ ä¸Š', 'å‡å»', 'ä¹˜ä»¥', 'é™¤ä»¥', 'å–ä½™', 'å¹‚',
                    'å¤§äº', 'å°äº', 'å¤§äºç­‰äº', 'å°äºç­‰äº', 'ä¸ç­‰äº', 'å¹¶ä¸”', 'æˆ–è€…', 'é',
                    'çš„', 'é•¿åº¦', 'ç±»', 'å±æ€§', 'æ–¹æ³•', 'æ„é€ å‡½æ•°', 'åˆ›å»º', 'è®¾ç½®',
                    'å°è¯•', 'æ•è·é”™è¯¯', 'æœ€ç»ˆ', 'æŠ›å‡ºé”™è¯¯', 'æ·»åŠ ', 'åˆ°', 'åˆ é™¤',
                    'è·³å‡ºå¾ªç¯', 'ç»§ç»­å¾ªç¯', 'ä¸ºçœŸ', 'ä¸ºå‡', 'ç©ºå€¼', 'å–æ•´', 'å–ä¸Šæ•´',
                    'ç»å¯¹å€¼', 'å¹³æ–¹æ ¹'
                ];
                
                let i = 0;
                while (i < line.length) {
                    // è·³è¿‡ç©ºç™½
                    if (/\s/.test(line[i])) {
                        i++;
                        continue;
                    }
                    
                    // å­—ç¬¦ä¸²
                    if (line[i] === '"' || line[i] === "'") {
                        const quote = line[i];
                        let j = i + 1;
                        let str = quote;
                        while (j < line.length && line[j] !== quote) {
                            if (line[j] === '\\' && j + 1 < line.length) {
                                str += line[j] + line[j + 1];
                                j += 2;
                            } else {
                                str += line[j];
                                j++;
                            }
                        }
                        if (j < line.length) {
                            str += quote;
                            j++;
                        }
                        tokens.push({ type: 'STRING', value: str, line: lineNum });
                        i = j;
                        continue;
                    }
                    
                    // æ•°å­—
                    if (/\d/.test(line[i])) {
                        let j = i;
                        let hasDecimal = false;
                        while (j < line.length && (/\d/.test(line[j]) || (line[j] === '.' && !hasDecimal))) {
                            if (line[j] === '.') hasDecimal = true;
                            j++;
                        }
                        tokens.push({ type: 'NUMBER', value: line.substring(i, j), line: lineNum });
                        i = j;
                        continue;
                    }
                    
                    // åˆ†éš”ç¬¦
                    if ('[],(){}:'.includes(line[i])) {
                        tokens.push({ type: 'DELIMITER', value: line[i], line: lineNum });
                        i++;
                        continue;
                    }
                    
                    // æ ‡è¯†ç¬¦æˆ–å…³é”®å­—
                    if (/[\w\u4e00-\u9fa5]/.test(line[i])) {
                        let j = i;
                        while (j < line.length && /[\w\u4e00-\u9fa5]/.test(line[j])) {
                            j++;
                        }
                        const word = line.substring(i, j);
                        
                        if (keywords.includes(word)) {
                            tokens.push({ type: 'KEYWORD', value: word, line: lineNum });
                        } else {
                            tokens.push({ type: 'IDENTIFIER', value: word, line: lineNum });
                        }
                        i = j;
                        continue;
                    }
                    
                    // æœªçŸ¥å­—ç¬¦
                    i++;
                }
                
                return tokens;
            }

            // è§£æå™¨
            parse(tokens) {
                this.tokens = tokens;
                this.currentToken = 0;
                
                const ast = {
                    type: 'Program',
                    body: []
                };
                
                while (this.currentToken < this.tokens.length) {
                    const stmt = this.parseStatement();
                    if (stmt) {
                        ast.body.push(stmt);
                    }
                }
                
                return ast;
            }

            getCurrentToken() {
                return this.tokens[this.currentToken] || null;
            }

            peekToken(offset = 0) {
                return this.tokens[this.currentToken + offset] || null;
            }

            consumeToken(expectedValue = null) {
                const token = this.getCurrentToken();
                if (expectedValue && token && token.value !== expectedValue) {
                    throw this.createError(`æœŸæœ› '${expectedValue}'ï¼Œä½†å¾—åˆ° '${token.value}'`);
                }
                this.currentToken++;
                return token;
            }

            skipNewlines() {
                while (this.getCurrentToken() && this.getCurrentToken().type === 'NEWLINE') {
                    this.currentToken++;
                }
            }

            parseStatement() {
                this.skipNewlines();
                const token = this.getCurrentToken();
                if (!token) return null;
                
                this.currentLine = token.line;
                
                try {
                    switch (token.value) {
                        case 'å®šä¹‰':
                            return this.parseDefinition();
                        case 'å¦‚æœ':
                            return this.parseIfStatement();
                        case 'å¾ªç¯':
                            return this.parseForLoop();
                        case 'å½“':
                            return this.parseWhileLoop();
                        case 'è¾“å‡º':
                            return this.parseOutput();
                        case 'è¿”å›':
                            return this.parseReturn();
                        case 'è°ƒç”¨':
                            return this.parseFunctionCall();
                        case 'æ·»åŠ ':
                            return this.parseArrayPush();
                        default:
                            // æ£€æŸ¥æ˜¯å¦æ˜¯èµ‹å€¼è¯­å¥ï¼ˆåŒ…æ‹¬æ•°ç»„å…ƒç´ èµ‹å€¼ï¼‰
                            if (token.type === 'IDENTIFIER') {
                                // é¢„è¯»æ£€æŸ¥æ˜¯å¦æ˜¯æ•°ç»„å…ƒç´ èµ‹å€¼
                                let lookahead = 1;
                                let isArrayAccess = false;
                                
                                                                if (this.peekToken(lookahead) && this.peekToken(lookahead).value === '[') {
                                    // è·³è¿‡æ•°ç»„ç´¢å¼•éƒ¨åˆ†
                                    lookahead++;
                                    let bracketCount = 1;
                                    while (lookahead < this.tokens.length - this.currentToken && bracketCount > 0) {
                                        const nextToken = this.peekToken(lookahead);
                                        if (nextToken.value === '[') bracketCount++;
                                        if (nextToken.value === ']') bracketCount--;
                                        lookahead++;
                                    }
                                    isArrayAccess = true;
                                }
                                
                                // æ£€æŸ¥æ˜¯å¦æœ‰ç­‰äºå·
                                if (this.peekToken(lookahead) && this.peekToken(lookahead).value === 'ç­‰äº') {
                                    if (isArrayAccess) {
                                        return this.parseArrayElementAssignment();
                                    } else {
                                        return this.parseAssignment();
                                    }
                                }
                            }
                            
                            // è·³è¿‡æœªè¯†åˆ«çš„token
                            this.consumeToken();
                            return null;
                    }
                } catch (error) {
                    this.errors.push(error);
                    // æ¢å¤åˆ°ä¸‹ä¸€è¡Œ
                    while (this.getCurrentToken() && this.getCurrentToken().type !== 'NEWLINE') {
                        this.currentToken++;
                    }
                    return null;
                }
            }

            parseDefinition() {
                this.consumeToken('å®šä¹‰');
                const nextToken = this.getCurrentToken();
                
                switch (nextToken.value) {
                    case 'å˜é‡':
                        return this.parseVariableDeclaration();
                    case 'å‡½æ•°':
                        return this.parseFunctionDeclaration();
                    case 'ç±»':
                        return this.parseClassDeclaration();
                    default:
                        throw this.createError('å®šä¹‰ååº”è¯¥è·Ÿéš å˜é‡ã€å‡½æ•° æˆ– ç±»');
                }
            }

            parseVariableDeclaration() {
                this.consumeToken('å˜é‡');
                const name = this.consumeToken();
                if (name.type !== 'IDENTIFIER') {
                    throw this.createError('å˜é‡åå¿…é¡»æ˜¯æ ‡è¯†ç¬¦');
                }
                
                this.consumeToken('ç­‰äº');
                const value = this.parseExpression();
                
                return {
                    type: 'VariableDeclaration',
                    name: name.value,
                    value: value,
                    line: name.line
                };
            }

            parseFunctionDeclaration() {
                this.consumeToken('å‡½æ•°');
                const name = this.consumeToken();
                if (name.type !== 'IDENTIFIER') {
                    throw this.createError('å‡½æ•°åå¿…é¡»æ˜¯æ ‡è¯†ç¬¦');
                }
                
                const params = [];
                if (this.getCurrentToken() && this.getCurrentToken().value === 'å‚æ•°ä¸º') {
                    this.consumeToken('å‚æ•°ä¸º');
                    
                    // è§£æå‚æ•°åˆ—è¡¨
                    while (this.getCurrentToken() && 
                           this.getCurrentToken().type === 'IDENTIFIER') {
                        params.push(this.consumeToken().value);
                        
                        if (this.getCurrentToken() && this.getCurrentToken().value === ',') {
                            this.consumeToken(',');
                        }
                    }
                }
                
                this.skipNewlines();
                
                // è§£æå‡½æ•°ä½“
                const body = [];
                while (this.getCurrentToken() && this.getCurrentToken().value !== 'ç»“æŸ') {
                    const stmt = this.parseStatement();
                    if (stmt) {
                        body.push(stmt);
                    }
                }
                
                this.consumeToken('ç»“æŸ');
                
                return {
                    type: 'FunctionDeclaration',
                    name: name.value,
                    params: params,
                    body: body,
                    line: name.line
                };
            }

            parseIfStatement() {
                this.consumeToken('å¦‚æœ');
                const condition = this.parseExpression();
                this.consumeToken('é‚£ä¹ˆ');
                this.skipNewlines();
                
                const thenBranch = [];
                while (this.getCurrentToken() && 
                       !['å¦åˆ™', 'å¦åˆ™å¦‚æœ', 'ç»“æŸ'].includes(this.getCurrentToken().value)) {
                    const stmt = this.parseStatement();
                    if (stmt) {
                        thenBranch.push(stmt);
                    }
                }
                
                let elseBranch = [];
                
                if (this.getCurrentToken() && this.getCurrentToken().value === 'å¦åˆ™å¦‚æœ') {
                    this.consumeToken('å¦åˆ™å¦‚æœ');
                    const elseIf = this.parseIfStatement();
                    elseBranch = [elseIf];
                } else if (this.getCurrentToken() && this.getCurrentToken().value === 'å¦åˆ™') {
                    this.consumeToken('å¦åˆ™');
                    this.skipNewlines();
                    
                    while (this.getCurrentToken() && this.getCurrentToken().value !== 'ç»“æŸ') {
                        const stmt = this.parseStatement();
                        if (stmt) {
                            elseBranch.push(stmt);
                        }
                    }
                }
                
                if (this.getCurrentToken() && this.getCurrentToken().value === 'ç»“æŸ') {
                    this.consumeToken('ç»“æŸ');
                }
                
                return {
                    type: 'IfStatement',
                    condition: condition,
                    thenBranch: thenBranch,
                    elseBranch: elseBranch
                };
            }

            parseForLoop() {
                this.consumeToken('å¾ªç¯');
                const variable = this.consumeToken();
                this.consumeToken('åœ¨');
                const list = this.parseExpression();
                this.consumeToken('ä¸­');
                this.skipNewlines();
                
                const body = [];
                while (this.getCurrentToken() && this.getCurrentToken().value !== 'ç»“æŸ') {
                    const stmt = this.parseStatement();
                    if (stmt) {
                        body.push(stmt);
                    }
                }
                
                this.consumeToken('ç»“æŸ');
                
                return {
                    type: 'ForLoop',
                    variable: variable.value,
                    list: list,
                    body: body
                };
            }

            parseWhileLoop() {
                this.consumeToken('å½“');
                const condition = this.parseExpression();
                this.consumeToken('æ—¶');
                this.skipNewlines();
                
                const body = [];
                while (this.getCurrentToken() && this.getCurrentToken().value !== 'ç»“æŸ') {
                    const stmt = this.parseStatement();
                    if (stmt) {
                        body.push(stmt);
                    }
                }
                
                this.consumeToken('ç»“æŸ');
                
                return {
                    type: 'WhileLoop',
                    condition: condition,
                    body: body
                };
            }

            parseOutput() {
                this.consumeToken('è¾“å‡º');
                const value = this.parseExpression();
                
                return {
                    type: 'OutputStatement',
                    value: value
                };
            }

            parseReturn() {
                this.consumeToken('è¿”å›');
                const value = this.parseExpression();
                
                return {
                    type: 'ReturnStatement',
                    value: value
                };
            }

            parseAssignment() {
                const name = this.consumeToken();
                this.consumeToken('ç­‰äº');
                const value = this.parseExpression();
                
                return {
                    type: 'Assignment',
                    name: name.value,
                    value: value
                };
            }

            parseArrayElementAssignment() {
                const name = this.consumeToken();
                this.consumeToken('[');
                const index = this.parseExpression();
                this.consumeToken(']');
                this.consumeToken('ç­‰äº');
                const value = this.parseExpression();
                
                return {
                    type: 'ArrayElementAssignment',
                    array: name.value,
                    index: index,
                    value: value
                };
            }

            parseArrayPush() {
                this.consumeToken('æ·»åŠ ');
                const value = this.parseExpression();
                this.consumeToken('åˆ°');
                const array = this.parseExpression();
                
                return {
                    type: 'ArrayPush',
                    value: value,
                    array: array
                };
            }

            parseExpression() {
                return this.parseLogicalOr();
            }

            parseLogicalOr() {
                let left = this.parseLogicalAnd();
                
                while (this.getCurrentToken() && this.getCurrentToken().value === 'æˆ–è€…') {
                    this.consumeToken('æˆ–è€…');
                    const right = this.parseLogicalAnd();
                    left = {
                        type: 'LogicalExpression',
                        operator: '||',
                        left: left,
                        right: right
                    };
                }
                
                return left;
            }

            parseLogicalAnd() {
                let left = this.parseEquality();
                
                while (this.getCurrentToken() && this.getCurrentToken().value === 'å¹¶ä¸”') {
                    this.consumeToken('å¹¶ä¸”');
                    const right = this.parseEquality();
                    left = {
                        type: 'LogicalExpression',
                        operator: '&&',
                        left: left,
                        right: right
                    };
                }
                
                return left;
            }

            parseEquality() {
                let left = this.parseRelational();
                
                while (this.getCurrentToken()) {
                    const op = this.getCurrentToken().value;
                    if (['ç­‰äº', 'ä¸ç­‰äº'].includes(op)) {
                        this.consumeToken();
                        const right = this.parseRelational();
                        left = {
                            type: 'BinaryExpression',
                            operator: op === 'ç­‰äº' ? '===' : '!==',
                            left: left,
                            right: right
                        };
                    } else {
                        break;
                    }
                }
                
                return left;
            }

            parseRelational() {
                let left = this.parseAdditive();
                
                while (this.getCurrentToken()) {
                    const op = this.getCurrentToken().value;
                    if (['å¤§äº', 'å°äº', 'å¤§äºç­‰äº', 'å°äºç­‰äº'].includes(op)) {
                        this.consumeToken();
                        const right = this.parseAdditive();
                        const jsOp = {
                            'å¤§äº': '>',
                            'å°äº': '<',
                            'å¤§äºç­‰äº': '>=',
                            'å°äºç­‰äº': '<='
                        }[op];
                        left = {
                            type: 'BinaryExpression',
                            operator: jsOp,
                            left: left,
                            right: right
                        };
                    } else {
                        break;
                    }
                }
                
                return left;
            }

            parseAdditive() {
                let left = this.parseMultiplicative();
                
                while (this.getCurrentToken()) {
                    const op = this.getCurrentToken().value;
                    if (['åŠ ä¸Š', 'å‡å»'].includes(op)) {
                        this.consumeToken();
                        const right = this.parseMultiplicative();
                        left = {
                            type: 'BinaryExpression',
                            operator: op === 'åŠ ä¸Š' ? '+' : '-',
                            left: left,
                            right: right
                        };
                    } else {
                        break;
                    }
                }
                
                return left;
            }

            parseMultiplicative() {
                let left = this.parsePower();
                
                while (this.getCurrentToken()) {
                    const op = this.getCurrentToken().value;
                    if (['ä¹˜ä»¥', 'é™¤ä»¥', 'å–ä½™'].includes(op)) {
                        this.consumeToken();
                        const right = this.parsePower();
                        const jsOp = {
                            'ä¹˜ä»¥': '*',
                            'é™¤ä»¥': '/',
                            'å–ä½™': '%'
                        }[op];
                        left = {
                            type: 'BinaryExpression',
                            operator: jsOp,
                            left: left,
                            right: right
                        };
                    } else {
                        break;
                    }
                }
                
                return left;
            }

            parsePower() {
                let left = this.parseUnary();
                
                if (this.getCurrentToken() && this.getCurrentToken().value === 'å¹‚') {
                    this.consumeToken();
                    const right = this.parsePower();
                    return {
                        type: 'BinaryExpression',
                        operator: '**',
                        left: left,
                        right: right
                    };
                }
                
                return left;
            }

            parseUnary() {
                if (this.getCurrentToken() && this.getCurrentToken().value === 'é') {
                    this.consumeToken();
                    return {
                        type: 'UnaryExpression',
                        operator: '!',
                        argument: this.parseUnary()
                    };
                }
                
                return this.parsePostfix();
            }

            parsePostfix() {
                let expr = this.parsePrimary();
                
                while (this.getCurrentToken()) {
                    if (this.getCurrentToken().value === 'çš„') {
                        this.consumeToken();
                        const property = this.consumeToken();
                        
                        if (property.value === 'é•¿åº¦') {
                            expr = {
                                type: 'PropertyAccess',
                                object: expr,
                                property: 'length'
                            };
                        }
                    } else if (this.getCurrentToken().value === '[') {
                        this.consumeToken('[');
                        const index = this.parseExpression();
                        this.consumeToken(']');
                        expr = {
                            type: 'MemberAccess',
                            object: expr,
                            index: index
                        };
                    } else {
                        break;
                    }
                }
                
                return expr;
            }

            parsePrimary() {
                const token = this.getCurrentToken();
                if (!token) return null;
                
                // æ•°å­—å­—é¢é‡
                if (token.type === 'NUMBER') {
                    this.consumeToken();
                    return {
                        type: 'NumberLiteral',
                        value: parseFloat(token.value)
                    };
                }
                
                // å­—ç¬¦ä¸²å­—é¢é‡
                if (token.type === 'STRING') {
                    this.consumeToken();
                    // å»é™¤å¼•å·å¹¶å¤„ç†è½¬ä¹‰å­—ç¬¦
                    const str = token.value.slice(1, -1)
                        .replace(/\\n/g, '\n')
                        .replace(/\\t/g, '\t')
                        .replace(/\\"/g, '"')
                        .replace(/\\'/g, "'")
                        .replace(/\\\\/g, '\\');
                    return {
                        type: 'StringLiteral',
                        value: str
                    };
                }
                
                // æ•°ç»„å­—é¢é‡
                if (token.value === '[') {
                    return this.parseArrayLiteral();
                }
                
                // æ‹¬å·è¡¨è¾¾å¼
                if (token.value === '(') {
                    this.consumeToken('(');
                    const expr = this.parseExpression();
                    this.consumeToken(')');
                    return expr;
                }
                
                // å‡½æ•°è°ƒç”¨
                if (token.value === 'è°ƒç”¨') {
                    return this.parseFunctionCallExpression();
                }
                
                // å†…ç½®å‡½æ•°è°ƒç”¨
                if (this.builtins.has(token.value)) {
                    this.consumeToken();
                    this.consumeToken('(');
                    const args = [];
                    
                    while (this.getCurrentToken() && this.getCurrentToken().value !== ')') {
                        args.push(this.parseExpression());
                        if (this.getCurrentToken() && this.getCurrentToken().value === ',') {
                            this.consumeToken(',');
                        }
                    }
                    
                    this.consumeToken(')');
                    
                    return {
                        type: 'BuiltinCall',
                        name: token.value,
                        arguments: args
                    };
                }
                
                // æ ‡è¯†ç¬¦
                if (token.type === 'IDENTIFIER') {
                    this.consumeToken();
                    return {
                        type: 'Identifier',
                        name: token.value
                    };
                }
                
                throw this.createError(`æœªé¢„æœŸçš„token: ${token.value}`);
            }

            parseArrayLiteral() {
                this.consumeToken('[');
                const elements = [];
                
                while (this.getCurrentToken() && this.getCurrentToken().value !== ']') {
                    elements.push(this.parseExpression());
                    if (this.getCurrentToken() && this.getCurrentToken().value === ',') {
                        this.consumeToken(',');
                    }
                }
                
                this.consumeToken(']');
                
                return {
                    type: 'ArrayLiteral',
                    elements: elements
                };
            }

            parseFunctionCallExpression() {
                this.consumeToken('è°ƒç”¨');
                const name = this.consumeToken();
                
                const args = [];
                if (this.getCurrentToken() && this.getCurrentToken().value === 'ä¼ å…¥') {
                    this.consumeToken('ä¼ å…¥');
                    
                    do {
                        args.push(this.parseExpression());
                        if (this.getCurrentToken() && this.getCurrentToken().value === ',') {
                            this.consumeToken(',');
                        } else {
                            break;
                        }
                    } while (true);
                }
                
                return {
                    type: 'FunctionCall',
                    name: name.value,
                    arguments: args
                };
            }

            // æ‰§è¡Œå¼•æ“
            execute(ast) {
                try {
                    this.executeBlock(ast.body);
                    return {
                        success: true,
                        output: this.output.join('\n'),
                        errors: this.errors
                    };
                } catch (error) {
                    this.errors.push(error);
                    return {
                        success: false,
                        output: this.output.join('\n'),
                        errors: this.errors
                    };
                }
            }

            executeBlock(statements, newScope = false) {
                if (newScope) {
                    this.pushScope();
                }
                
                try {
                    for (const stmt of statements) {
                        if (!stmt) continue;
                        
                        const result = this.executeStatement(stmt);
                        
                        if (result) {
                            if (result.type === 'return') {
                                return result;
                            } else if (result.type === 'break') {
                                if (this.loopStack.length === 0) {
                                    throw this.createError('è·³å‡ºå¾ªç¯è¯­å¥åªèƒ½åœ¨å¾ªç¯å†…ä½¿ç”¨');
                                }
                                return result;
                            } else if (result.type === 'continue') {
                                if (this.loopStack.length === 0) {
                                    throw this.createError('ç»§ç»­å¾ªç¯è¯­å¥åªèƒ½åœ¨å¾ªç¯å†…ä½¿ç”¨');
                                }
                                return result;
                            }
                        }
                    }
                } finally {
                    if (newScope) {
                        this.popScope();
                    }
                }
            }

            executeStatement(stmt) {
                if (!stmt) return null;
                
                this.currentLine = stmt.line || this.currentLine;
                
                switch (stmt.type) {
                    case 'VariableDeclaration':
                        const value = this.evaluateExpression(stmt.value);
                        this.setVariable(stmt.name, value);
                        break;
                        
                    case 'FunctionDeclaration':
                        this.functions.set(stmt.name, stmt);
                        break;
                        
                    case 'Assignment':
                        const assignValue = this.evaluateExpression(stmt.value);
                        this.setVariable(stmt.name, assignValue);
                        break;
                        
                    case 'ArrayElementAssignment':
                        const array = this.getVariable(stmt.array);
                        if (!Array.isArray(array)) {
                            throw this.createError(`${stmt.array} ä¸æ˜¯æ•°ç»„`);
                        }
                        const index = this.evaluateExpression(stmt.index);
                        const newValue = this.evaluateExpression(stmt.value);
                        array[index] = newValue;
                        break;
                        
                    case 'OutputStatement':
                        const output = this.evaluateExpression(stmt.value);
                        this.output.push(this.toString(output));
                        break;
                        
                    case 'ReturnStatement':
                        return {
                            type: 'return',
                            value: this.evaluateExpression(stmt.value)
                        };
                        
                    case 'IfStatement':
                        const condition = this.evaluateExpression(stmt.condition);
                        if (this.toBoolean(condition)) {
                            const result = this.executeBlock(stmt.thenBranch);
                            if (result) return result;
                        } else if (stmt.elseBranch.length > 0) {
                            const result = this.executeBlock(stmt.elseBranch);
                            if (result) return result;
                        }
                        break;
                        
                    case 'ForLoop':
                        const list = this.evaluateExpression(stmt.list);
                        if (!Array.isArray(list)) {
                            throw this.createError('å¾ªç¯çš„å¯¹è±¡å¿…é¡»æ˜¯æ•°ç»„');
                        }
                        
                        this.loopStack.push(true);
                        try {
                            for (const item of list) {
                                this.pushScope();
                                this.setVariable(stmt.variable, item);
                                
                                const result = this.executeBlock(stmt.body);
                                this.popScope();
                                
                                if (result) {
                                    if (result.type === 'break') {
                                        break;
                                    } else if (result.type === 'continue') {
                                        continue;
                                    } else if (result.type === 'return') {
                                        return result;
                                    }
                                }
                            }
                        } finally {
                            this.loopStack.pop();
                        }
                        break;
                        
                    case 'WhileLoop':
                        this.loopStack.push(true);
                        try {
                            while (this.toBoolean(this.evaluateExpression(stmt.condition))) {
                                const result = this.executeBlock(stmt.body);
                                if (result) {
                                    if (result.type === 'break') {
                                        break;
                                    } else if (result.type === 'continue') {
                                        continue;
                                    } else if (result.type === 'return') {
                                        return result;
                                    }
                                }
                            }
                        } finally {
                            this.loopStack.pop();
                        }
                        break;
                        
                    case 'ArrayPush':
                        const targetArray = this.evaluateExpression(stmt.array);
                        if (!Array.isArray(targetArray)) {
                            throw this.createError('åªèƒ½å‘æ•°ç»„æ·»åŠ å…ƒç´ ');
                        }
                        targetArray.push(this.evaluateExpression(stmt.value));
                        break;
                        
                    default:
                        throw this.createError(`æœªçŸ¥çš„è¯­å¥ç±»å‹: ${stmt.type}`);
                }
            }

            evaluateExpression(expr) {
                if (!expr) return null;
                
                switch (expr.type) {
                    case 'NumberLiteral':
                        return expr.value;
                        
                    case 'StringLiteral':
                        return expr.value;
                        
                    case 'ArrayLiteral':
                        return expr.elements.map(el => this.evaluateExpression(el));
                        
                    case 'Identifier':
                        return this.getVariable(expr.name);
                        
                    case 'BinaryExpression':
                        return this.evaluateBinaryExpression(expr);
                        
                    case 'UnaryExpression':
                        const arg = this.evaluateExpression(expr.argument);
                        if (expr.operator === '!') {
                            return !this.toBoolean(arg);
                        }
                        throw this.createError(`æœªçŸ¥çš„ä¸€å…ƒè¿ç®—ç¬¦: ${expr.operator}`);
                        
                    case 'LogicalExpression':
                        const left = this.evaluateExpression(expr.left);
                        if (expr.operator === '||') {
                            return this.toBoolean(left) ? left : this.evaluateExpression(expr.right);
                        } else if (expr.operator === '&&') {
                            return this.toBoolean(left) ? this.evaluateExpression(expr.right) : left;
                        }
                        throw this.createError(`æœªçŸ¥çš„é€»è¾‘è¿ç®—ç¬¦: ${expr.operator}`);
                        
                    case 'FunctionCall':
                        return this.callFunction(expr.name, expr.arguments);
                        
                    case 'BuiltinCall':
                        const args = expr.arguments.map(arg => this.evaluateExpression(arg));
                        return this.builtins.get(expr.name)(args);
                        
                    case 'PropertyAccess':
                        const object = this.evaluateExpression(expr.object);
                        if (expr.property === 'length') {
                            if (typeof object === 'string' || Array.isArray(object)) {
                                return object.length;
                            }
                        }
                        return object[expr.property];
                        
                    case 'MemberAccess':
                        const container = this.evaluateExpression(expr.object);
                        const index = this.evaluateExpression(expr.index);
                        if (Array.isArray(container) || typeof container === 'string') {
                            return container[index];
                        }
                        throw this.createError('åªèƒ½å¯¹æ•°ç»„æˆ–å­—ç¬¦ä¸²ä½¿ç”¨ç´¢å¼•è®¿é—®');
                        
                    default:
                        throw this.createError(`æœªçŸ¥çš„è¡¨è¾¾å¼ç±»å‹: ${expr.type}`);
                }
            }

            evaluateBinaryExpression(expr) {
                const left = this.evaluateExpression(expr.left);
                const right = this.evaluateExpression(expr.right);
                
                switch (expr.operator) {
                    case '+':
                        return left + right;
                    case '-':
                        return left - right;
                    case '*':
                        return left * right;
                    case '/':
                        if (right === 0) {
                            throw this.createError('é™¤æ•°ä¸èƒ½ä¸ºé›¶');
                        }
                        return left / right;
                    case '%':
                        return left % right;
                    case '**':
                        return Math.pow(left, right);
                    case '>':
                        return left > right;
                    case '<':
                        return left < right;
                    case '>=':
                        return left >= right;
                    case '<=':
                        return left <= right;
                    case '===':
                        return left === right;
                    case '!==':
                        return left !== right;
                    default:
                        throw this.createError(`æœªçŸ¥çš„äºŒå…ƒè¿ç®—ç¬¦: ${expr.operator}`);
                }
            }

            callFunction(name, argExprs) {
                const func = this.functions.get(name);
                if (!func) {
                    throw this.createError(`æœªå®šä¹‰çš„å‡½æ•°: ${name}`);
                }
                
                // è®¡ç®—å‚æ•°å€¼
                const args = argExprs.map(arg => this.evaluateExpression(arg));
                
                // åˆ›å»ºæ–°çš„ä½œç”¨åŸŸ
                this.pushScope();
                this.callStack.push(name);
                
                try {
                    // ç»‘å®šå‚æ•°
                    for (let i = 0; i < func.params.length; i++) {
                        this.setVariable(func.params[i], args[i]);
                    }
                    
                    // æ‰§è¡Œå‡½æ•°ä½“
                    const result = this.executeBlock(func.body);
                    
                    if (result && result.type === 'return') {
                        return result.value;
                    }
                    
                    return null;
                } finally {
                    this.callStack.pop();
                    this.popScope();
                }
            }

            // å˜é‡ä½œç”¨åŸŸç®¡ç†
            pushScope() {
                const newScope = new Map();
                newScope.__parent__ = this.variables;
                this.variables = newScope;
            }

            popScope() {
                if (this.variables.__parent__) {
                    this.variables = this.variables.__parent__;
                }
            }

            setVariable(name, value) {
                this.variables.set(name, value);
            }

            getVariable(name) {
                let scope = this.variables;
                while (scope) {
                    if (scope.has(name)) {
                        return scope.get(name);
                    }
                    scope = scope.__parent__;
                }
                throw this.createError(`æœªå®šä¹‰çš„å˜é‡: ${name}`);
            }

            // è¾…åŠ©æ–¹æ³•
            toString(value) {
                if (value === null) return 'ç©ºå€¼';
                if (value === undefined) return 'æœªå®šä¹‰';
                if (typeof value === 'string') return value;
                if (typeof value === 'number') return String(value);
                if (typeof value === 'boolean') return value ? 'ä¸ºçœŸ' : 'ä¸ºå‡';
                if (Array.isArray(value)) {
                    return '[' + value.map(v => this.toString(v)).join(', ') + ']';
                }
                return String(value);
            }

            toBoolean(value) {
                if (value === null || value === undefined) return false;
                if (value === false || value === 0 || value === '') return false;
                if (Array.isArray(value) && value.length === 0) return false;
                return true;
            }

            createError(message) {
                const error = new Error(message);
                error.line = this.currentLine;
                error.stack = this.callStack.slice();
                return error;
            }

            run(code) {
                this.reset();
                
                try {
                    // è¯æ³•åˆ†æ
                    const tokens = this.tokenize(code);
                    
                    // è¯­æ³•åˆ†æ
                    const ast = this.parse(tokens);
                    
                    // æ‰§è¡Œ
                    const result = this.execute(ast);
                    
                    return result;
                } catch (error) {
                    this.errors.push(error);
                    return {
                        success: false,
                        output: this.output.join('\n'),
                        errors: this.errors
                    };
                }
            }
        }

        // UI äº¤äº’ä»£ç 
        const interpreter = new ChineseInterpreter();

        function updateLineNumbers() {
            const textarea = document.getElementById('code');
            const lineNumbers = document.getElementById('lineNumbers');
            const lines = textarea.value.split('\n').length;
            
            let lineNumbersHtml = '';
            for (let i = 1; i <= lines; i++) {
                lineNumbersHtml += i + '\n';
            }
            lineNumbers.textContent = lineNumbersHtml;
        }

        function updateCursorPosition() {
            const textarea = document.getElementById('code');
            const text = textarea.value.substring(0, textarea.selectionStart);
            const lines = text.split('\n');
            const currentLine = lines.length;
            const currentColumn = lines[lines.length - 1].length + 1;
            
            document.getElementById('cursor-position').textContent = 
                `è¡Œ ${currentLine}, åˆ— ${currentColumn}`;
        }

        function runCode() {
            const code = document.getElementById('code').value;
            const outputDiv = document.getElementById('output');
            
            // æ¸…ç©ºè¾“å‡º
            outputDiv.innerHTML = '<div class="info">ğŸš€ å¼€å§‹è¿è¡Œ...</div>\n';
            
            // è¿è¡Œä»£ç 
            const result = interpreter.run(code);
            
            if (result.success) {
                outputDiv.innerHTML = '<div class="success">âœ… è¿è¡ŒæˆåŠŸ</div>\n\n';
                if (result.output) {
                    outputDiv.innerHTML += `<div>${escapeHtml(result.output)}</div>`;
                }
            } else {
                outputDiv.innerHTML = '<div class="error">âŒ è¿è¡Œå‡ºé”™</div>\n\n';
                
                // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                for (const error of result.errors) {
                    let errorMsg = `<div class="error">é”™è¯¯`;
                    if (error.line) {
                        errorMsg += ` (ç¬¬ ${error.line} è¡Œ)`;
                    }
                    errorMsg += `: ${escapeHtml(error.message || error)}</div>`;
                    
                    if (error.stack && error.stack.length > 0) {
                        errorMsg += `<div class="error">è°ƒç”¨æ ˆ: ${error.stack.join(' -> ')}</div>`;
                    }
                    
                    outputDiv.innerHTML += errorMsg;
                }
                
                // å¦‚æœæœ‰éƒ¨åˆ†è¾“å‡ºï¼Œä¹Ÿæ˜¾ç¤ºå‡ºæ¥
                if (result.output) {
                    outputDiv.innerHTML += '\n<div class="warning">éƒ¨åˆ†è¾“å‡ºï¼š</div>\n';
                    outputDiv.innerHTML += `<div>${escapeHtml(result.output)}</div>`;
                }
            }
        }

        function clearCode() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ä»£ç å—ï¼Ÿ')) {
                document.getElementById('code').value = '';
                updateLineNumbers();
                updateCursorPosition();
            }
        }

        function clearOutput() {
            document.getElementById('output').innerHTML = '';
        }

        function formatCode() {
            // ç®€å•çš„ä»£ç æ ¼å¼åŒ–
            let code = document.getElementById('code').value;
            
            // ç§»é™¤å¤šä½™çš„ç©ºè¡Œ
            code = code.replace(/\n\s*\n\s*\n/g, '\n\n');
            
            // ä¿®å¤ç¼©è¿›
            const lines = code.split('\n');
            const formattedLines = [];
            let indentLevel = 0;
            
            for (let line of lines) {
                const trimmed = line.trim();
                
                // å‡å°‘ç¼©è¿›çš„å…³é”®å­—
                if (trimmed === 'ç»“æŸ' || trimmed === 'å¦åˆ™' || trimmed.startsWith('å¦åˆ™å¦‚æœ')) {
                    indentLevel = Math.max(0, indentLevel - 1);
                }
                
                // æ·»åŠ ç¼©è¿›
                if (trimmed) {
                    formattedLines.push('    '.repeat(indentLevel) + trimmed);
                } else {
                    formattedLines.push('');
                }
                
                // å¢åŠ ç¼©è¿›çš„å…³é”®å­—
                if (trimmed.startsWith('å®šä¹‰ å‡½æ•°') || trimmed.startsWith('å®šä¹‰ ç±»') ||
                    trimmed.startsWith('å¦‚æœ') || trimmed === 'å¦åˆ™' || 
                    trimmed.startsWith('å¦åˆ™å¦‚æœ') || trimmed.startsWith('å¾ªç¯') ||
                    trimmed.startsWith('å½“')) {
                    indentLevel++;
                }
            }
            
            document.getElementById('code').value = formattedLines.join('\n');
            updateLineNumbers();
        }

        function saveCode() {
            const code = document.getElementById('code').value;
            const blob = new Blob([code], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ç¨‹åº.han';
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadCode() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.han,.txt';
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        document.getElementById('code').value = e.target.result;
                        updateLineNumbers();
                        updateCursorPosition();
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // åˆå§‹åŒ–
        document.getElementById('code').addEventListener('input', updateLineNumbers);
        document.getElementById('code').addEventListener('input', updateCursorPosition);
        document.getElementById('code').addEventListener('click', updateCursorPosition);
        document.getElementById('code').addEventListener('keyup', updateCursorPosition);

        // åˆå§‹åŒ–æ—¶æ›´æ–°è¡Œå·
        updateLineNumbers();
        updateCursorPosition();
        
        // è‡ªåŠ¨è¿è¡Œç¤ºä¾‹ä»£ç 
        setTimeout(() => runCode(), 500);
    </script>
</body>
</html>
